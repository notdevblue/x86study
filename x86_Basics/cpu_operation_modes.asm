; # CPU Operation Modes

; ## Real Mode

; 리얼 모드는 오리지널 Intel 8086에서 넘어온 것임.
; 일반적으로는 몰라도 됨. (BIOS 에서 직접적으로 호출되는 부트로더나, DOS 기반 시스템을 개발하는게 아닌 이상)

; Intel 8086 은 메모리를 20비트 주소로 접근함. 하지만 프로세서 자체는 16비트였음.
; Intel 이 20비트 주소공간을 16비트 공간으로 매핑하는 방법을 개발함.
; 오늘날의 x86 프로세서들은 호환성을 위해 소위 말하는 리얼 모드에서 시작함. 8086의 행동을 아주 약간의 차이점만 가지고 모방하는 작동 방식임.

; 리얼 모드에선, 최종 메모리 주소를 산출하기 위해 세그먼트와 오프셋 레지스터가 같이 사용됨.
; 세그먼트 레지스터의 값에 16이 곱해지고 (왼쪽으로 4비트 옮겨짐), 오프셋이 결과에 더해짐. 이는 1MB의 사용 가능한 주소 공간을 제공함

; 이 주소 지정 방식의 특이한 점은 0xFFFF (가능한 제일 높은 곳) 의 세그먼트 주소가 사용중이라면 1MB 이상의 주소를 접근할 수 있다는 것임.
; 8086과 8088에선, 1MB 이상의 구역은 메모리의 최하위로 들어감. 하지만 80286 이후부터는 65520 바이트 까지는 A20 Address line 이 활성화 되었다면, 위와 같은 방식으로 접근이 가능함.
; https://en.wikibooks.org/wiki/X86_Assembly/16,_32,_and_64_Bits#The_A20_Gate_Saga 에서 더 읽을 수 있음.

; 리얼 모드 세그멘테이션과 프로텍티드 모드 멀티 세그먼트 메모리 모델이 공유하는 하나의 이점은, 모든 주소는 다른 주소와 관련되어 제공되어야 한다는 것임 (이는 세그먼트 베이스 주소임)
; 프로그램은 고유의 주소 공간을 가질 수 있고, 세그먼트 레지스터를 신경쓰지 않아도 됨. 따라서, 프로그램을 실행하기 위해 포인터가 재배치될 필요가 없음.
; 프로그램은 near call 과 jump 를 같은 세그먼트에서 할 수 있고, 데이터는 항상 세그먼트 베이스 주소와 관련이 있음 .
; (리얼 모드 주소 지정 방식은, 세그먼트 레지스터에 로드된 값들을 통해 계산되기 때문임)

; DOS 의 *.COM 파일 형식이 바로 위의 행동을 함. 파일의 요소들이 메모리에 로드되고 명목적으로 실행됨.
; 하지만 리얼 모드 세그멘트는 항상 64KB 이기 때문에, COM 파일은 이보다 클 수 없었음. (사실 DOS는 맨 첫 세그멘트의 256bytes 를 하우스키핑 데이터로 사용하기 때문에, 실제로는 65280 bytes 안에 넣어야 했음.)
; 이것은 많은 시간동안 문제가 되지 않았음.

; ## Protected Mode

; 

; ### Flat Memory Model

; ### Muti-Segmented Memory Model

; ## Long Mode

; 롱 모드는 64비트 모드를 의미함