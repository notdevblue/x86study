# [Addressing memory](https://en.wikibooks.org/wiki/X86_Assembly/16,_32,_and_64_Bits)

## 8086 and 80186

원래의 8086은 16비트 크기의 레지스터만 가지고 있었음. [0 - (2^16 - 1)] 범위 안의 값을 효율적으로 저장할 수 있음. (간단하게 마랗면 65536 가지의 다른 바이트들, 또는 64 kibibytes.)
하지만 주소 버스 (메모리 컨트롤러의 연결 지점, 주소를 받아서 안에 있는 내용을 얻어서 CPU의 데이터 버스에 넘김.) 의 크기는 20비트임. 효율적으로 1 mebibyte 의 메모리를 주소 지정할 수 있음.

이는 모든 레지스터는 혼자서 주소 버스의 전채 넓이를 활용할 수 없다는 의미임. 4 bits 를 사용하지 않고 남겨, 사용 가능한 주소를 16개로 축소함 (1024 KiB / 64 Kib = 16).

<br/>

문제는 이것임: "20비트 주소 공간이 16비트 레지스터에 어떻게 담길 수 있는가?". 이를 해결하기 위해 Intel의 엔지니어들은 세그먼트 레지스터 CS, DS, ES, SS를 떠올림. 20-bit 주소로 변경하기 위해, 먼저 주소를 16으로 나눈 뒤, 몫을 세그먼트 레지스터에 넣고, 나머지를 오프셋 레지스터에 넣음. 이는 CS:IP 로 표현됨. (CS 가 세그먼트이고, IP 가 오프셋이라는 의미) 비슷하게, 주소가 SS:SP 로 써졌다면, SS가 세그먼트고, SP가 오프셋이라는 의미임.

이는 반대 방향에도 적용됨. 변환하는 대신 20비트 주소를 만들기 위해, 세그먼트 레지스터의 16-bit 값을 왼쪽으로 4번 밀고 (shift 4 times, addr << 4) 주소 버스에 넣음. 그리고 다른 레지스터에 존재하는 오프셋을 그냥 버스에 넣으면 20비트 주소가 만들어짐.

### Example

CS = 258C, IP = 0012(16진수) 인 경우, CS:IP 는 "CS x 16 + IP" 와 같은 20비트 주소를 가리킴. 이는 이와 같음.

> 258C x 10(16진수) + 0012(16진수) = 258C0 + 0012(16진수) = 258D2

20비트 주소는 absolute (or linear) address 라고도 불리고, Segment:Offset 표현(CS:IP)은 Segmented address 라고도 불림.
이 분리는 레지스터가 16비트 인코딩보다 큰 값을 가질 수 없기에 필요했음.

32-bit 또는 64-bit 프로세서에서 Protected Mode 를 이용해 프로그래밍 할 때는, 레지스터가 주소 버스 전부를 담기을 수 있는 크기를 가짐, 따라서 세그멘티드 주소를 없엠. 오직 linear/logical 주소만 이 "flat addressing" 모드에서 사용됨. 하지만 Segment:Offset 구조는 여전히 호환성을 위해 지원됨.

<br/>

물리 주소와 세그먼티드 주소는 1 대 1 대입이 아니라는걸 알아야 함. 물리 주소 하나에는 하나 이상의 세그먼트 주소가 존재함.
예를 들어 세그먼트 표현인 B000:8000 과 B200:6000 을 생각해보면, 둘다 물리 주소 B8000 으로 계산됨.

> B000:8000 = B000 x 10(16진수) + 8000(16진수)  = B0000 + 8000(16진수) = B8000 <br/>
> B200:6000 = B200 x 10(16진수) + 6000(16진수)  = B2000 + 6000(16진수) = B8000

하지만, 적절한 매핑 방식을 사용하면 위와 같은 문제를 피할 수 있음. 이러한 매핑 방식은 물리 주소를 선형 변환하여서 하나의 고유한 세그먼트된 주소를 만듬. 이 변환을 다시 되돌리려면, 매핑 방식 [f(x)] 는 단순히 반전됨.

예를 들어, 세그먼트 부분이 물리 주소를 10(16진수) 로 나눈 것과 같다면, 오프셋은 그의 나머지와 같음, 오직 하나의 세그먼트된 주소가 생성됨. (오프셋은 0F보다 크지 않음) 물리 주소 B8000은 (B800 / 10(16진수)):(B8000 mod 10(16진수)) 또는 B800:0 으로 매핑됨. 이 세그먼트 표현은 특별한 이름이 있음. 이러한 주소는 "Normalized Address" (정규화된 주소) 라고 불림.

<br/>

CS:IP (Code Segment: Instruction Pointer) 는 다음에 실행할 명령이 있는 20-bit 의 물리 메모리 주소를 나타냄.
이와 같이 SS:SP (Stack Segment: Stack Pointer) 는 스택의 맨 위 20-bit 절대 주소를 가리킴. (8086은 이를 값 push/pop 하는데 사용함)

## Protected Mode (80286+)

보기에는 좀 그렇지만, 후기에 나온 CPU들이 사용하는 보호 주소 체계임. 80286은 protected mode가 있음. 24개의 주소 라인이 다 사용 가능하고, 이는 16MiB의 메모리 만큼 주소 지정이 가능함. 보호 모드에선, CS, DS, ES, SS 레지스터들은 세그먼트가 아닌 selectors 임, 프로그램이 사용중이었던 물리 메모리 블럭을 가리킴. 이 모드에서 `CS:IP = 0010:2400` 포인터 값은 아레와 같이 사용됨.

CS가 가지고 있는 0010(16) 은 selector table의 오프셋임, 특정한 selector(선택자) 를 가리키고 있음. 선택자는 메모리 블럭의 시작 위치를 나타내는 24-bit 값이 가지고 있고, 블럭이 얼마나 긴지 나타내는 16-bit 값, 블럭이 쓰기 가능한지, 현재 물리적으로 메모리에 있는지, 그리고 기타 정보를 가진 플래그들로 이루어짐.

메모리 블럭이 16400(16) 이라는 24-bit 주소를 가리키고 있다고 가정함, 실제 주소는 16400(16) + 2400(16) = 16680(16) 임. 선택자가 블럭이 2400(16) 바이트 만큼 길다는 정보를 가지고 있다면, 참조는 해당 블록 밖에 있는 바로 다음 바이트이고, 이는 예외를 발생시킴.

운영 체제는 프로그램이 소유하고 있지 않는 메모리의 읽기를 허용하지 않음. 그리고 만약 블럭이 읽기 전용이라면, 어떤 코드 세그먼트 메모리에 쓰기를 해야 하는지 지정하지 않으면 프로그램끼리 덮어쓰게 됨.
읽기 전용의 메모리에 쓰기를 시도하면 예외가 발생함.

386에서는 CS와 IP가 32 bits 로 확장됬기 때문에, 이 방식은 불필요해짐. 선택자는 물리 주소 00000000(16)을 가리키고, 32-bit 레지스터는 4 GiB의 메모리 만큼의 주소를 지정할 수 있기 때문임. 하지만 선택자는 악성 프로그램에게서 메모리를 보호하기 위해 여전히 사용됨. 예를 들어, 윈도우의 프로그램이 소유하지 않은 메모리를 읽거나 쓰려고 했을 때, 선택자가 설정한 규칙을 위반하게 되고, 예외를 일으키게 되고, 윈도우는 "General protection fault" 메세지와 함께 프로그램을 종료하게 됨.

## 32-Bit Addressing

32-bit 주소는 4GiB의 메모리를 감당할 수 있음, 이 말은 즉 32-bit 프로세서에선 오프셋 주소를 사용할 필요가 없다는 의미임. 대신 "Flat addressing" 이라고 불리는 방식을 사용함. 레지스터에 있는 주소는 물리 메모리 주소를 직접 가리킴. 세그먼트 레지스터는 다른 세그먼트를 정의하는데 사용됨. 그래서 프로그램은 스택 구역을 실행하지 않고, 실수로 데이터 구역에서 스택 작업을 수행하지 않음.
