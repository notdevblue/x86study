# [Addressing memory](https://en.wikibooks.org/wiki/X86_Assembly/16,_32,_and_64_Bits)

## 8086 and 80186

원래의 8086은 16비트 크기의 레지스터만 가지고 있었음. [0 - (2^16 - 1)] 범위 안의 값을 효율적으로 저장할 수 있음. (간단하게 마랗면 65536 가지의 다른 바이트들, 또는 64 kibibytes.)
하지만 주소 버스 (메모리 컨트롤러의 연결 지점, 주소를 받아서 안에 있는 내용을 얻어서 CPU의 데이터 버스에 넘김.) 의 크기는 20비트임. 효율적으로 1 mebibyte 의 메모리를 주소 지정할 수 있음.

이는 모든 레지스터는 혼자서 주소 버스의 전채 넓이를 활용할 수 없다는 의미임. 4 bits 를 사용하지 않고 남겨, 사용 가능한 주소를 16개로 축소함 (1024 KiB / 64 Kib = 16).

<br/>

문제는 이것임: "20비트 주소 공간이 16비트 레지스터에 어떻게 담길 수 있는가?". 이를 해결하기 위해 Intel의 엔지니어들은 세그먼트 레지스터 CS, DS, ES, SS를 떠올림. 20-bit 주소로 변경하기 위해, 먼저 주소를 16으로 나눈 뒤, 몫을 세그먼트 레지스터에 넣고, 나머지를 오프셋 레지스터에 넣음. 이는 CS:IP 로 표현됨. (CS 가 세그먼트이고, IP 가 오프셋이라는 의미) 비슷하게, 주소가 SS:SP 로 써졌다면, SS가 세그먼트고, SP가 오프셋이라는 의미임.

이는 반대 방향에도 적용됨. 변환하는 대신 20비트 주소를 만들기 위해, 세그먼트 레지스터의 16-bit 값을 왼쪽으로 4번 밀고 (shift 4 times, addr << 4) 주소 버스에 넣음. 그리고 다른 레지스터에 존재하는 오프셋을 그냥 버스에 넣으면 20비트 주소가 만들어짐.

### Example

## Protected Mode (80286+)

## 32-Bit Addressing
