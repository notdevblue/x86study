# The A20 Gate Saga

예전에 말한 것 처럼, 8086 프로세서는 20개의 주소 라인이 있음. (A0에서 A19) 그래서 총 1MiB (또는 2^20)만큼의 메모리 공간을 주소 지정 가능했음. 하지만 그때는 오직 16-bit 의 레지스터만 존재했기 때문에 Segment:Offset 방식을 떠올림. 16-bit 레지스터는 64KiB (또는 2^16)이상의 메모리를 접근하는 것이 불가능하기 때문임. 그래서 이는 프로그램이 1MiB 의 메모리를 전부 접근할 수 있게 함.

하지만 이 세그멘테이션 방식은 사이드 이팩트가 있음. 프로그램은 1MiB 전부를 읽을 수 있지만, 사실 그거보다 더 읽을 수 있음...

Segment:Offset 표현을 20bit 표현으로 변환하는 방식을 다시 한번 알아봄.

변환:
> Segment:Offset = Segment x 16 + Offset

이제 이 표현식으로 가능한 최대 주소값을 알아볼 것. Segment와 Offset을 최대값으로 설정하고 20-bit 절대 물리 주소로 변환할 것, Segment = FFFF(16), Offset = FFFF(16) 을 사용함.

FFFF:FFFF 를 20-bit 선형 주소로 변환할 것.
```go
FFFF:FFFF
    = FFFF x 10(16) + FFFF
    = FFFF0 (1MiB - 16bytes) + FFFF(64KiB)
    = FFFFF + FFF0 = 1MiB + FFF0 bytes
```
* Note: **FFFFF 는 1MiB 와 동일하고, FFF0 은 64KiB - 16 bytes 와 동일함.**

<br/>

**결론:** Real mode 프로그램은 실제로 `(1MiB + 64KiB - 16)` bytes 만큼의 메모리를 참조할 수 있음.

"접근" 대신 "참조" 를 사용한 것을 주목. 프로그램은 위에서 표시된 정도의 메모리를 참조할 수 있지만, 실제로 접근이 가능한지 아닌지는 실제로 존재하는 주소 라인의 수에 따라 달라짐. 그래서 8086은 프로그램이 1MiB 이상의 메모리를 접근할 시, 주소 라인에 넣어진 주소는 20-bits 이상이기 때문에 절대로 접근할 수 없음. 이는 주소의 wrapping 이라는 결과로 돌아옴.

예를 들어 코드가 1MiB를 참조하고 있다면, 감싸져서 메모리 위치 0 을 가리킬 것임. 이처럼 1MiB + 1 은 감싸져서 주소 1 을 가리킴. (또는 0000:0001)

과거에는 이 기능을 이용해 코드를 작성한 엄청나게 개쩌는 프로그래머들이 있었음. 주소가 감싸져서 코드가 더 빠르고, 좀더 짧게 되었음. 이 기능을 통해 32KiB 의 최상위 바이트 (1MiB 까지의 32KiB) 와 32KiB 의 최하위 바이트를 세그먼트 레지스터 새로고침 없이 접근했음.

간단한 수학임. Segment:Offset 표현에서 Segment 를 상수로 만들면, Offset은 16-bit 값이기 때문에 64KiB (또는 2^16) 정도 공간의 메모리를 돌아다닐 수 있음. 이제 세그먼트 레지스터가 1MiB 의 32KiB 아레를 가리키게 하면, 1MiB 경계까지의 32KiB 메모리 접근이 가능하고, 추가 32KiB는 궁극적으로 최하위 바이트로 감싸지게 됨.

과거의 엄청나개 개쩌는 프로그래머들은 더욱 많은 주소 라인을 가진 프로세서가 개발될 것이라는 사실을 간과했음. *(빌 게이츠는 "도대체 누가 640KB 보다 더 많은 메모리가 필요한가요?" 라는 말을 남겼고, 다른 프로그래머들도 이와 같은 생각이었을 것임.)*

8086이 출시되고 바로 2년 뒤인 1982년에 인탤은 주소 라인이 24개인 80286을 출시했음. 이론적으로 과거의 8086 프로그램과 호환이 되었지만, 실제로는 대부분의 프로그램이 out-of-bounds 주소가 하위 메모리 세그먼트로 감싸지는 구현에 의존했기에, 올바르게 작동하지 않았음. 그래서 호환성을 위해, IBM 엔지니어들은 A20 주소 라인을 키보드 컨트롤러를 통해 라우팅 했고, A20 호환 모드를 활성화/비활성화 하는 기능을 제공했음.

왜 키보드 컨트롤러를 사용했냐면, 거기에는 사용되지 않는 핀이 존재했기 떄문임. 80286은 (나온지 얼마 안된)8086과 호환이 가능하다고 마케팅되었기 때문에, 80286이 bug-for-bug 호환이 안 되어서 8086의 코드도 작동이 되지만, 8086에서 더 빠르다면 업그레이드한 소비자들은 매우 화가 날 것이기 때문이었음.
