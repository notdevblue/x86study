# [Intrinsic Data Types](https://en.wikibooks.org/wiki/X86_Assembly/Intrinsic_Data_Types)

엄밀히 말하자면, 어셈블리는 high-level 언어처럼 미리 정의된 자료형이 없음. 아무 범용 레지스터는 2개 또는 4개의 연속된 바이트들을 가질 수 있음. 이 바이트가 숫자, 글자, 또는 다른 데이터를 나타내는지는 상관 없음. 이와 같이, 메모리 블럭에는 구체적인 타입이 할당되어 있지 않기에, 원하는 값으로 할당할 수 있음.

그 말은, 어셈블리에선 데이터를 두가지의 범주로 구분할 수 있음. integer(정수) 와 floating point(부동 소수점). 부동 소수점을 레지스터에 넣고 정수인것 처럼 대할 순 있지만, 결과는 예상과 다를 것임. 그래서 이 두개를 별도로 생각하는 것이 좋음.

## Integers

정수는 완전한 숫자를 의미함. 양수 또는 음수 (컴퓨터에서 0은 양수로 취급됨). <br/>
8086 아키택처에선, 8-bit 와 16-bit 크기로 제공되었고 이는 간단한 작업 대부분을 가능하게 했음. <br/>
80386 부턴 데이터 버스가 32-bit 작업을 지원하게 확장되었고, 이 크기의 정수 작업도 허용됨. <br/>
x86 아키택처에의 최신 시스템은 64-bit 명령을 지원함. 하지만 64-bit 운영 체제가 최적의 효과를 위해 필요함. 

컴퓨터는 2의 보수를 이용해 음수를 저장함. 최상위 비트는 부호를 나타내고, 설정되있다면 음수를 의미함. 양수의 경우, 일반적인 방식으로 비트들이 저장되고, 음수인 경우, 최고값과의 차이로 비트가 저장됨. 이는 오버플로우 시 발생하는 효과로 쉬운 작업이 가능함. 하지만, 값을 부호 없는 형식으로 저장할 수 있음. 몇몇 어셈블리 명령은 부호 비트에 대해 약간씩 다르게 행동함. 따라서, 부호가 존재하는 정수와 부호가 존재하지 않는 정수는 서로 조금의 차이가 있음.

## Floating point numbers

부동 소수점은 (유한) 실수의 하위 집합임. 주로 소수점 앞 뒤의 숫자를 포함함, 3.14159 처럼. 소수점이 숫자 맨 뒤에 존재하는 Integer 와는 다르게, 부동 소수점은 연속되는 숫자의 아무 부분에 있을 수 있음.

원레 부동 소수점은 메인 프로세서의 부분이 아니었음, 에뮬레이팅 소프트웨어가 필요했음. 하지만 부동소수점 데이터 타입에 연산을 가능하게끔 해주는 보조 프로세서가 존재했음, 그리고 486DX 부터 CPU 안으로 직접 통합됨.

그래서, 부동 소수점 연산은 모든 프로세서랑 호환되는것은 아님. 이 형식의 연산을 해야 하는 경우, 백업 코드로 소프트웨어 라이브러리를 사용하는걸 추천함.

현대의 프로세서들은 IEEE 754 스텐다드를 준수함, 이는 위키북 [Floating Point](https://en.wikibooks.org/wiki/Floating_Point) 에서 설명되있음. 상대적으로 짧은 2의 제곱의 합으로 표현될 수 없는 숫자는 항상 근사값으로 나타낸다는걸 명심해야 함.
