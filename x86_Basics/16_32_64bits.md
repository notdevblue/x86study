# [16, 32, and 64 Bits](https://en.wikibooks.org/wiki/X86_Assembly/16,_32,_and_64_Bits)

x86 어셈블리를 사용할 때, 16, 32 64비트 아키택처의 차이점을 고려해야 함.

아레에서는 bit 넒이의 따른 아키택처의 기본적인 차이점을 알아갈 것.

## Registers

### 16-bit

8086과 후속 x86프로세서에서 찾을 수 있는 레지스터들은 다움과 같음.

AX, BX, CX, DX, SP, BP, SI, DI, CS, DS, SS, ES, IP 그리고 EFLAGS.

이들은 전부 16비트 폭을 가짐.

<br/>

DOS에서 32비트 윈도우까지는 "debug.exe" 라는 8086에 대해 배울때 매우 도움되는 프로그램을 DOS 쉘에서 실행할 수 있음.

만약 DOSBox나 FreeDOS를 사용한다면 [FreeDOS에서 재공](https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.2/repos/pkg-html/debug.html)하는 "debug.exe" 를 사용할 수 있음.

#### AX, BX, CX, DX

이 범용 레지스터는 8-bit 레지스터로도 접근이 가능함.

AX = AH (high 8-bit), AL (low 8-bit) 임.

#### SI, DI

이 레지스터들은 데이터 공간에 대한 오프셋으로 사용됨. 기본적으로 SI 는 DS 데이터 세그먼트의 오프셋이고, DI 는 ES 엑스트라 세그먼트의 오프셋으로 사용됨. 하지만 둘다 오버라이드가 가능함.

#### SP

이것은 스택 포인터, 주로 스택 세그먼트 SS의 오프셋임. 데이터는 임시 저장을 위해 스택 위로 쌓이게 되고, 필요할 때 위에서 빠지게 됨.

#### BP

스택 프레임, 주로 스택 세그먼트 SS 의 오프셋으로 취급됨. 서브루틴이 호출되었을 때, 서브루틴의 파라미터들은 주로 스택에 밀어 넣어짐. 그리고 BP 는 서브루틴이 실행될 때 SP 의 값으로 설정됨. 
BP는 중간에 스택이 얼마나 사용되었는지에 상관 없이 스택에 있는 파라미터들을 찾는데 사용될 수 있음.

#### CS, DS, SS, ES

세그먼트 포인더들. 각각 code segment, data segment, stack segment 그리고 extra segment 메모리의 오프셋임.

#### IP

인스트럭션 포인터. 코드 세그먼트 CS 의 오프셋임. 현재 실행중인 지침을 향함. (points) 

#### FLAGS (F)

프로세서의 현재 상태를 나타내는 (어쩔때는 설정하는) 다수의 single-bit 들임.

### 32-bit

칩들이 32비트 데이터 버스를 지원하기에 따라, 레지스터 또한 같이 32비트로 넓어지게 되었음.

32비트 레지스터의 이름은 16비트 레지스터 앞에 'E' 를 붙인 방식임.

#### EAX, EBX, ECX, EDX, ESP, EBP, ESI, EDI

위에서 설명한 레지스터의 32비트 버전임.

#### EIP

32비트 버전의 IP. 32비트 시스템일때, 반드시 IP 대신 사용해야 함.

#### EFLAGS

16비트 FLAGS 레지스터의 확장된 버전

### 64-bit

64비트 레지스터의 이름은 32비트 레지스터에서 시작을 'R' 로 한다는 차이점만 존재함

#### RAX, RBX, RCX, RDX, RSP, RBP, RSI, RDI

위에서 설명한 레지스터의 64비트 버전임

#### RIP

64비트 인스트럭션 포인터, EIP 대신 사용해야 함. (주소 공간이 4GB 이상이면 부정확하기 때문, 그리고 4GB 미만이어도 일어날 수 있음.)

#### R8-15

64비트에서 새로 추가 레지스터들임. 위의 레지스터들이 0부터 7인것처럼 가정함.

R8-R15는 8, 16, 32-bit 레지스터로 접근이 가능함. R8을 예시로 하면, 각각 R8B, R8W, R8D 임.
64비트 버전의 x86은 RSP, RBP, RSI, RDI 의 하위 바이트를 직접 접근할 수 있게 함.
예를 들어, RSP의 하위 바이트는 SPL을 통해 접근할 수 있음.
이 레지스터들의 8-15바이트를 접근하는 방법은 AH가 AX 를 허용하기 때문에 존재하지 않음.

### 128-bit, 256-bit and 512-bit (SSE/AVX)

64비트 x86은 SSE2를 포함함 (32비트 x86의 확장), 이는 특정한 지침을 위해 128비트 레지스터를 제공함.

2011년 이후에 만들어진 대부분의 CPU는 AVX도 가짐. 256비트로 레지스터가 제공되는 추가 확장임.

몇몇은 AVX-512도 존재함. 512비트로 늘리고, 16개의 레지스터를 추가함.

#### XMM0 ~ 7

SSE2 이상.

#### XMM8 ~ 15

SSE3, AMD (인텔은 말고) SSE2 이상.

#### YMM9 ~ 15

AVX, YMM 레지스터는 이에 해당하는 XMM 레지스터를 하위 바이트로 가짐.

#### ZMM0 ~ 15

AVX-512F, ZMM 레지스터는 이에 해당하는 YMM 레지스터를 하위 바이트로 가짐.

#### ZMM16 ~ 31

AVX-512F, AVX-512VL 이 구현되지 않았으면, 더 좁은 모드로는 주소 지정이 불가능한 512비트 레지스터들임.

#### XMM16 ~ 31

AVX-512VL, ZMM 레지스터의 하위 1/4임.

#### YMM16 ~ 31

AVX-512VL, ZMM 레지스터의 하위 비트임.
