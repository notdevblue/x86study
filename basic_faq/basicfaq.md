# [Basic FAQ](https://en.wikibooks.org/wiki/X86_Assembly/Basic_FAQ)

## 컴퓨터는 어셈블리를 어떻게 읽고 이해하는가?

실제로 읽고 이해하지 않음. 어셈블러가 기계어로 변환해서 컴퓨터가 읽을 수 있게 함.

하나의 어셈블리 지침은, 하나의 기계어임.

그래서 단순한 필사자가 위의 행동을 종이, 연필, 그리고 어셈블리 지침 책만으로도 대신할 수 있음.

예전에는 이 행동이 흔했고, 간단한 컴퓨터 프로그램을 만드는데에는 필요한 행동이기도 했음.
*(예를 들면, 스티브 위즈니악이 BASIC 인터프리터를 Apple I 에 사용하기 위해 6502 기계어로 직접 번역함)*

## 리눅스/도스/윈도우, 별로 차이가 없는가?

차이가 없으면서도 있음.

x86 기계어는 프로세서에 의존함. x86 버전의 리눅스와 윈도우는 둘다 x86 기계어로 만들어짐.

리눅스와 윈도우에서의 x86 기계어 프로그래밍은 약간의 차이점이 있음

1. 리눅스 환경에서 제일 유명한 어셈블러는 GAS 어셈블러임. AT&T 문법을 사용하고, Netwide 어셈블러를 사용함, NASM 이라고도 알려졌고, MASM 과 비슷한 문법을 사용함.
2. 윈도우 환경에서 제일 유명한 어셈블러는 MASM 임. Intel 문법을 사용함. 하지만 많은 윈도우 유저는 NASM 을 사용함.
3. 리눅스와 윈도우에서 사용 가능한 소프트웨어 인터럽트와, 이것의 함수들은 서로 다름.
4. 리눅스와 윈도우에서 사용 가능한 코드 라이브러리는 서로 다름.

같은 어셈블러를 사용하면, 각각의 운영 체제에서 작성한 기계어 기본은 같음. 하지만 리눅스와 윈도우는 서로 다르게 상호작용 해야 함.

## 어느 기계어가 최고인가?

취향 차이다.

여러 어셈블러의 차이점은 섹션 2에서 소개할 것.

## 기계어를 알아야 하는가?

*os 만들어보려고 지금 위에 페이지 통으로 번역하면서 공부하는데 이건 스킵할거임*

## 코드를 어떤 방식으로 작성해야 하는가?

대부분의 어셈블러는 기계어 코드 지침이 캐리지 리턴으로 구분된 동립적인 한 줄에 있기를 요구함.

대부분의 어셈블러는 지침 사이에 공백문자를 허용함.

어떤 방식으로 작성할지는 유저에 달림. 아레는 몇몇 예시임.

전부다 줄맞춤

```asm
Label1:
mov ax, bx
add ax, bx
jmp Label3
Label2:
mov ax, bx
...
```

다른 방법은 라벨들을 하나의 열에 두고, 지침들을 다른 열에 두는 방식

```asm
Label1: mov ax, bx
        add ax, bx
        jmp Label3
Label2: mov ax, cx
...
```

또 다른 방법은 라벨들을 하나의 열에 두고, 지침들은 들여쓰기 하는 방식

```asm
Label1:
    mov ax, bx
    add ax, bx
    jmp Label3
Label2:
    mov ax, cx
```

또 또 다른 방법은 라벨과 지침을 다른 열에 두고, 라벨을 본인의 고유한 줄에 두는 방식

```asm
Label1:
        mov ax, bx
        add ax, bx
        jmp Label3
Label2:
        mov ax, bx
```

여러가지의 방법이 있음. 하지만 공통적인 규칙이 존재함
1. 라벨을 명확하게 작성. 다른 프로그래머가 이해할 수 있게
2. 많은 구조들(들여쓰기 같은 거)은 코드를 읽기 쉽게 만듬
3. 주석을 통해 설명. 기계어는 한번에 의미를 알기 어려움
